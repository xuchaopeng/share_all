我们从第一个部分开始，组件通讯。
父组件 - 子组件的通讯。
第一种通过props传值。 在child1上面定义一个动态属性title，在组件内部通过props定义接收。
第二种通过$attrs属性，在组件child1上定义两个name属性，这来两个属性在组件内部是没有通过props定义（接收）的。
通常，我们把这些没有通过props定义的属性，叫做非法属性。然而在组件内部，可以通过，$attrs属性来获取。我刚刚定义的非法属性，会默认渲染到组件的根元素上面，
我们可以通过inat:false,来去掉这些默认行为。我还可以通过v-bind="$attrs"来将这些非法属性，渲染到组件内部指定的标签上。这个p标签上，有了name1 name2这几个属性。
第三中通过$refs来获取当前子组件的实例化对象。在组件child2上设置ref属性，在mounted生命周期，重新改变这个title
第四种通过$children[1]来拿到组件对象，重新设置title,其实这也实现了父子组件的一个通讯。
注意，当存在异步组件，或动态组件的时候，获取组件的顺序是不保证的。
怎么理解呢? children是一个数组，每个成员存放的是当前子组件的实例化对象，但是psuh 的进去的顺序是按照组件渲染的顺序。

子组件 - 父组件的通讯
子组件派发事件  父组件订阅事件

兄弟组件之间  通过寻找共同的父被组件的搭桥，我看这个实例。在child2通过给父组件注册一个事件foo， 在child1中通过服组件的$emit派发一个foo事件,并传递一个参数。
